
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="SilenceDut的代码世界">
    <title>如何优雅的实现一个高效、高性能、异步数据实时刷新的列表 - SilenceDut的代码世界</title>
    <meta name="author" content="SilenceDut">
    
    
        <link rel="icon" href="http://silencedut.com/assets/images/avatar.png">
    
    
    <meta name="description" content="Android的业务开发中。列表需求很常见也很重要的部分，列表承载的信息多，涉及的的协议多，布局也多，尤其一些复杂的列表，不管是用ListView还是RecyclerView，使用不当会带来很多的性能问题和后期的维护问题，形成一套规范的，高性能的列表开发模式很有必要。
案例分析用一些案例说明一下吧(只是用一些App里的截图来做类比，并不知其协议类型和实现方式)
类似的列表不容易解决的主要在两个方面">
<meta property="og:type" content="blog">
<meta property="og:title" content="如何优雅的实现一个高效、高性能、异步数据实时刷新的列表">
<meta property="og:url" content="http://silencedut.com/2019/01/24/如何优雅的实现一个高效、高性能、异步数据实时刷新的列表/index.html">
<meta property="og:site_name" content="SilenceDut的代码世界">
<meta property="og:description" content="Android的业务开发中。列表需求很常见也很重要的部分，列表承载的信息多，涉及的的协议多，布局也多，尤其一些复杂的列表，不管是用ListView还是RecyclerView，使用不当会带来很多的性能问题和后期的维护问题，形成一套规范的，高性能的列表开发模式很有必要。
案例分析用一些案例说明一下吧(只是用一些App里的截图来做类比，并不知其协议类型和实现方式)
类似的列表不容易解决的主要在两个方面">
<meta property="og:image" content="https://ws2.sinaimg.cn/large/006tNc79gy1fyx83bvbyjj30py0wu4az.jpg">
<meta property="og:image" content="https://ws3.sinaimg.cn/large/006tNc79gy1fz8y3v6fyhj30u00i2400.jpg">
<meta property="og:image" content="https://ws3.sinaimg.cn/large/006tNc79gy1fyxa6v140cj31eo0i6wj5.jpg">
<meta property="og:image" content="https://ws3.sinaimg.cn/large/006tNc79gy1fz73pvxepdj30qc046ac1.jpg">
<meta property="og:image" content="https://ws3.sinaimg.cn/large/006tNc79gy1fz8y3v6fyhj30u00i2400.jpg">
<meta property="og:updated_time" content="2019-01-23T18:48:44.843Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="如何优雅的实现一个高效、高性能、异步数据实时刷新的列表">
<meta name="twitter:description" content="Android的业务开发中。列表需求很常见也很重要的部分，列表承载的信息多，涉及的的协议多，布局也多，尤其一些复杂的列表，不管是用ListView还是RecyclerView，使用不当会带来很多的性能问题和后期的维护问题，形成一套规范的，高性能的列表开发模式很有必要。
案例分析用一些案例说明一下吧(只是用一些App里的截图来做类比，并不知其协议类型和实现方式)
类似的列表不容易解决的主要在两个方面">
<meta name="twitter:image" content="https://ws2.sinaimg.cn/large/006tNc79gy1fyx83bvbyjj30py0wu4az.jpg">
    
    
        
    
    
        <meta property="og:image" content="http://silencedut.com/assets/images/avatar.png"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-nuvue6sithwirecbhvw3dkaobiojqvtadsnhguwi7k04xklybw5djl1smadp.min.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


<header id="header" data-behavior="3">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/ ">SilenceDut的代码世界</a>
    </h1>
    
        
            <a  class="header-right-icon "
                href="#about">
        
        
            <i class="fa fa-lg fa-avatar.png"></i>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="3">
    
        <div class="sidebar-profile">
            <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.png"/>
            </a>
            <span class="sidebar-profile-name">SilenceDut</span>
        </div>
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/ "
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">首页</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">标签</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://github.com/SilenceDut" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                    <span class="sidebar-button-desc">GitHub</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="mailto:silencedutchman@foxmail.com" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                    <span class="sidebar-button-desc">邮箱</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="http://www.itvincent.net/" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                    <span class="sidebar-button-desc">itvincent</span>
                </a>
        </li>
        
    </ul>
    
</nav>

            
            <div id="main" data-behavior="3"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post" itemscope itemType="http://schema.org/BlogPosting">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title" itemprop="headline">
            如何优雅的实现一个高效、高性能、异步数据实时刷新的列表
        </h1>
    
    <div class="post-meta">
    <time itemprop="datePublished" datetime="2019-01-24T02:22:24+08:00">
	
		    1月 24, 2019
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/all-categories/Android/">Android</a>, <a class="category-link" href="/all-categories/Android/OpenSourceProject/">OpenSourceProject</a>


    
</div>

</div>
    
    <div class="post-content markdown" itemprop="articleBody">
        <div class="main-content-wrap">
            <p>Android的业务开发中。列表需求很常见也很重要的部分，列表承载的信息多，涉及的的协议多，布局也多，尤其一些复杂的列表，不管是用ListView还是RecyclerView，使用不当会带来很多的性能问题和后期的维护问题，形成一套规范的，高性能的列表开发模式很有必要。</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>用一些案例说明一下吧(只是用一些App里的截图来做类比，并不知其协议类型和实现方式)<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fyx83bvbyjj30py0wu4az.jpg" alt=""></p>
<p>类似的列表不容易解决的主要在两个方面：</p>
<a id="more"></a>
<ol>
<li><p>先不管列表里每个Item的具体UI,首先列表是可通过下拉刷新和广播通知变化，数据应该也只能全量下发，更新频率可能特别高，列表的长度也可能很长比如几百条（一些聊天列表或者在线用户列表可能存在数据量更大的情况）,如果过高频率的刷新很容易造成页面卡顿。</p>
</li>
<li><p>从UI上看有很多特征，昵称、头像、等级、各种特权等等，而且大部分<br>情况一条协议是无法包含所有信息，可能是很多个版本需求的迭代，涉及到多个协议，比如我们项目中这种情况大部分是只返回一些uid列表，一般先将基本的数据设置到adapter里显示，同时根据uid去查询相应的各个对应的协议，异步返回结果，然后更新对应的Item，<strong>因为都是异步的数据很难先拼接好数据再更新列表</strong>。还有些情况是Item中的一些数据可能会根据通知出现变化，比如等级升级了，离开了。或者在线状态等，如下图常见的聊天列表根据通知更新数据的：<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fz8y3v6fyhj30u00i2400.jpg" alt=""><br>在线状态，最新的聊天内容，时间，未读消息数等，如果item中可变的数据太多，更新的代码写起来会很繁琐。</p>
</li>
</ol>
<h3 id="列表的性能问题"><a href="#列表的性能问题" class="headerlink" title="列表的性能问题"></a>列表的性能问题</h3><p>使用过页面卡顿工具<a href="https://developer.android.com/studio/command-line/systrace">systrace</a>分析页面卡顿或者掉帧的应该有一定的经验，如果页面存在比较复杂的列表，或者更新频繁的列表，在一些低端机，有的甚至配置较好的手机上会出现卡顿情况，及时感觉不到卡顿，用<a href="https://developer.android.com/studio/command-line/systrace">systrace</a>应该也能看到相对其他View比较多的掉帧（也可称为Jank），谷歌根据比较多的一些app的数据也有类似的结论，列表的使用不当是很多卡顿的来源<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fyxa6v140cj31eo0i6wj5.jpg" alt=""></p>
<p>列表容易造成卡顿主要原因是相对其他View，列表承载的内容多，更新又比较频繁，而且还有Holder的重建复用以及无效刷新等带来的很多的子Item View的UI刷新,列表变化频繁(如删除、移动、新增等)，动画会带来很大的UI性能消耗,根据原因主要从下面几个个方面来提高列表的性能：</p>
<ul>
<li>即使调用再多次notifyData，列表内容不变化的时候不刷新UI，内容变化的时候只刷新需要UI更新的Item</li>
<li>列表内容相关的异步数据或者通知需要更新列表时高效更新</li>
<li>对一个Item，只更新需要变化的部分View</li>
<li>根据具体情形，可以禁用列表的动画。</li>
</ul>
<h3 id="不易用的DiffUtil"><a href="#不易用的DiffUtil" class="headerlink" title="不易用的DiffUtil"></a>不易用的DiffUtil</h3><p>DiffUtil是support-v7:24.2.0中的新工具类，它用来比较两个数据集，寻找出旧数据集-》新数据集的最小变化量。并不是一个新的工具，这里如果只是介绍如何使用DiffUtil也没任何意义。DiffUtil虽然提供很久，能高性能的刷新列表，但是其使用情况上来看，可能并不理想，主要原因是：<strong>非常不易使用</strong></p>
<ul>
<li><p><strong>写起来麻烦：</strong> 使用时需要实现DiffCallBack抽象类，需要实现至少四个方法这样即使一个很简单的列表也要写上很多的代码，如果列表里有多种Type的Holder,写起来就更加的臃肿耦合，</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Callback</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Callback</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getOldListSize</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getNewListSize</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">areItemsTheSame</span><span class="params">(<span class="keyword">int</span> var1, <span class="keyword">int</span> var2)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">areContentsTheSame</span><span class="params">(<span class="keyword">int</span> var1, <span class="keyword">int</span> var2)</span></span>;</div><div class="line"></div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getChangePayload</span><span class="params">(<span class="keyword">int</span> oldItemPosition, <span class="keyword">int</span> newItemPosition)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><span id = "jump1">     </p>
</li>
<li><strong>容易崩溃：</strong> DiffCallBack计算数据差量时需要放到异步线程，稍有不慎容易崩溃，<br>  <code>java.lang.IndexOutOfBoundsException,Inconsistency detected. Invalid view holder adapter positionViewHolder{65752ee position=2 id=-1, oldPos=2, pLpos:2 scrap [attachedScrap]</code>,<br>  <code>java.lang.IndexOutOfBoundsException
  Inconsistency detected. Invalid item position 16(offset:16).state:64</code>,  <code>java.lang.IllegalArgumentException: Scrapped or attached views may not be recycled. isScrap:false isAttached:true</code>，<br>  类似上面的崩溃相信使用过DiffUtil应该都不陌生，根本原因是列表的数据变化的时候没有立刻调用adapter刷新列表，而DiffUtil的计算需要放在异步线程来处理，需要操作数据和展示数据的在不用的线程，同步比较难控制,尤其是在列表长度变化的时候又更新比较频繁的时候。虽然提供<em>AsyncListDiffer</em>的帮助类，但并不能减少这些崩溃发生的概率，而且即使知道大概的原因，这些崩溃还是很难避免。</li>
</ul>
<h4 id="不易增、删、更新的列表"><a href="#不易增、删、更新的列表" class="headerlink" title="不易增、删、更新的列表"></a>不易增、删、更新的列表</h4><p>以更新列表为例：</p>
<p><strong>类似需要异步请求数据的</strong><br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fz73pvxepdj30qc046ac1.jpg" alt=""></p>
<p><strong>类似通知更新数据的：</strong><br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fz8y3v6fyhj30u00i2400.jpg" alt=""></p>
<p>实现更新的方式可能有很多种方式，但需要注意:</p>
<ol>
<li><p>不要在Holder里监听数据变化，不管是类似EventBus的广播还是LiveData，虽然如果项目里用到LiveData,可能在holder里通过<code>livedate.observer(context,Observer)</code>很方便监听回调，但是因为Holder的没有明显的生命周期，可能会频繁被复用以及Holder的回收不可见等状态不可控，如果是使用LiveData，导致被频繁绑定observer，或者出现内存泄漏等各种难以定位的问题。下面是Google关于列表View的使用建议</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">* When the async code is done, you should update the data, not the views. After updating the data, tell the adapter that the data changed. The RecyclerView gets note of this and re-renders your view.</div><div class="line">* When working with recycling views (ListView or RecyclerView), you cannot know what item a view is representing. In your case, that view gets recycled before the async work is done and is assigned to a different item of your data.</div><div class="line">* So never modify the view. Always modify the data and notify the adapter. bindView should be the place where you treat these cases.</div></pre></td></tr></table></figure>
<p> 简单来说就是<strong>异步数据结果回来不应该在Holder里直接改变view的状态，而是应该改变数据，然后通过adapter来改变View。</strong> 主要原因还是上面说的Holder创建与销毁，可见不可见等状态很难控制</p>
</li>
<li><p>不在Holder里更新就只能在外部更新，但如果使用了DiffUtil，外部更新数据不容易实现。首先异步数据获取到后或者广播通知列表中的数据需要变化时，找到需要的变更项更改数据,类型下面的实现</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> allDatas = ...</div><div class="line"></div><div class="line"><span class="comment">//广播通知变化，更新数据</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onDataChanged</span><span class="params">(<span class="keyword">data</span>:<span class="type">T</span>)</span></span> &#123;</div><div class="line">   <span class="keyword">val</span> updateItemIdex = allDatas. findIndex(<span class="keyword">object</span>.dataFeture)</div><div class="line">   allDatas.<span class="keyword">set</span>(updateItemIdex,<span class="keyword">data</span>)</div><div class="line">   </div><div class="line">   or 直接找到对象，改变值</div><div class="line">   </div><div class="line">   <span class="keyword">val</span> needChangeData = allDatas.findData(<span class="keyword">object</span>.dataFeture)</div><div class="line">   needChangeData.info = <span class="keyword">data</span>.info</div><div class="line">   </div><div class="line">&#125;</div><div class="line"></div><div class="line">or </div><div class="line"></div><div class="line"><span class="comment">// 异步请求得到数据，更新数据</span></div><div class="line">fub onDataFetched(<span class="keyword">data</span>:T) &#123;</div><div class="line">    <span class="keyword">val</span> updateItemIdex = allDatas. findIndex(<span class="keyword">object</span>.dataFeture)</div><div class="line">   allDatas.<span class="keyword">set</span>(updateItemIdex,<span class="keyword">data</span>)</div><div class="line">   </div><div class="line">   or 直接找到对象，改变值</div><div class="line">   </div><div class="line">   <span class="keyword">val</span> needChangeData = allDatas.findData(<span class="keyword">object</span>.dataFeture)</div><div class="line">   needChangeData.info = <span class="keyword">data</span>.info</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="comment">//在全部数据中找到需要变更的数据，更改数据中的某些值。这种更常见</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findData</span><span class="params">(dataFeture : <span class="type">Long</span>)</span></span>:T &#123;</div><div class="line">    <span class="keyword">return</span> allDatas.find...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//在全部数据中找到需要变更的数据位置Index,替换数据</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findIndex</span><span class="params">(dataFeture : <span class="type">Long</span>)</span></span>:Index &#123;</div><div class="line">    <span class="keyword">return</span> allDatas.find...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把列表数据更新后，需要让UI的Item也同步更新</p>
<ul>
<li><p>一种是局部刷新：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adapter.notifyItemChanged(updateItemIdex);</div></pre></td></tr></table></figure>
<p>直接刷新单个Item很容易出现<a href="#jump1">不同线程同时处理数据带来的崩溃问题等</a>，再具体点这种更新数据方式如果此时有类似mAdapter.setDatas(mDatas)刷新全量列表的行为，而此时的新的列表的长度和原来的不同，就有可能出现上述的崩溃。全量和局部可能都是基于通知或异步数据的结果所有很难控制先后顺序。</p>
</li>
<li><p>还有一种是调用全量更新：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(<span class="keyword">new</span> DiffCallBack(mDatas, newDatas), <span class="keyword">true</span>);</div><div class="line"></div><div class="line">diffResult.dispatchUpdatesTo(mAdapter);</div><div class="line"></div><div class="line">mDatas = newDatas;</div><div class="line">mAdapter.setDatas(mDatas);</div></pre></td></tr></table></figure>
<p>由于使用了DiffUtil的原因，可能会觉得不会刷新所有的UI，这样性能会提高。但这样使用会出现新的问题，这种方式有个很严重的问题就是每次都要进行DiffCallBack的差分运算，虽然可以异步线程里处理，但是数据量较大，异步数据较多，更新频繁的时候会导致cpu被大量占用，从而带来更严重的界面卡顿问题。<br><span id = "jump2">  </p>
<p>还有很麻烦的地方就是一个异步结果返回更改单个Item里的数据时，这时很有可能你看不到列表的更新。StackOverflow 有类似的问题：<a href="https://stackoverflow.com/questions/46008457/update-single-item-in-recyclerview-with-diffutil">Update single item in RecyclerView with DiffUtil</a>。因为每次更新的时候你需要<strong>new一个新的对象</strong>，然后将不需要改变的内容复制，需要改变的进行赋值。而不是像上面那样找到原来的数据进行更改局部，因为原数据<strong>对象</strong>已经在源数据列表里，虽然创建新的列表，但在更新单个对象的时候因为是同一个对象所以旧的数据列表肯定同步更新，导致做差分对比的结果肯定是不需要更新UI(因为是同一个对象)，所以只能创建新的对象，这对更新频繁和每个Item有很多异步返回数据的列表来说是个很大的消耗，写起来也会非常非常繁琐。</p>
</li>
</ul>
</li>
</ol>
<p>同样的，在一些频繁插入、删除、增加数据的列表项使用不当也有容易出现各种各样的问题。</p>
<h3 id="diffadapter：一种高效、高性能的方案"><a href="#diffadapter：一种高效、高性能的方案" class="headerlink" title="diffadapter：一种高效、高性能的方案"></a>diffadapter：一种高效、高性能的方案</h3><p><a href="https://github.com/SilenceDut/diffadapter">diffadapter</a>就是根据实际项目中各种复杂的列表需求，同时为了解决DiffUtil使用不方便，容易出错而实现的一个<strong>高效，高性能的列表库，侵入性低，方便接入</strong>，致力于将列表需求的开发精力用于具体的Item Holder上，而不用花时间在一些能通用的和业务无关的地方。<a href="https://github.com/SilenceDut/diffadapter">diffadapter</a>使用DiffUtil作为来做最小更新，屏蔽外部调用<strong>DiffUtil</strong>的接口。无需自行实现DiffUtil,只用实现简单的数据接口和展示数据的Holder，不用自己去实现Adapter来管理数据和Holder之间的关系，不用考虑diffutil的实现细节在,就能快速的开发出一个高性能的复杂列表需求。</p>
<p><strong>使用方式和细节见<a href="https://github.com/SilenceDut/diffadapter">diffadapter</a></strong>，有详细的demo和使用说明</p>

            
        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/RecyclerView/">RecyclerView</a> <a class="tag tag--primary tag--small t-link" href="/tags/性能/">性能</a>

            </div>
        
        <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--disabled">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/11/26/优雅的使用Handler,避免内存泄漏和页面崩溃/" data-tooltip="通过LifecycleOwner,优雅的使用Handler">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://silencedut.com/2019/01/24/如何优雅的实现一个高效、高性能、异步数据实时刷新的列表/">
                <i class="fa fa-google-plus"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://silencedut.com/2019/01/24/如何优雅的实现一个高效、高性能、异步数据实时刷新的列表/">
                <i class="fa fa-facebook-official"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://silencedut.com/2019/01/24/如何优雅的实现一个高效、高性能、异步数据实时刷新的列表/">
                <i class="fa fa-twitter"></i>
            </a>
        </li>
        
            <li class="post-action">
                <a class="post-action-btn btn btn--default" href="#ds-thread">
                    <i class="fa fa-comment-o"></i>
                </a>
            </li>
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#">
            
                <i class="fa fa-list"></i>
            </a>
        </li>
    </ul>
</div>


        
            
                <div id="ds-thread" class="ds-thread" data-thread-key="2019/01/24/如何优雅的实现一个高效、高性能、异步数据实时刷新的列表/"
     data-title="如何优雅的实现一个高效、高性能、异步数据实时刷新的列表" data-url="http://silencedut.com/2019/01/24/如何优雅的实现一个高效、高性能、异步数据实时刷新的列表/">
</div>

            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 SilenceDut. All Rights Reserved.
    </span>
  	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="3">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--disabled">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/11/26/优雅的使用Handler,避免内存泄漏和页面崩溃/" data-tooltip="通过LifecycleOwner,优雅的使用Handler">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://silencedut.com/2019/01/24/如何优雅的实现一个高效、高性能、异步数据实时刷新的列表/">
                <i class="fa fa-google-plus"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://silencedut.com/2019/01/24/如何优雅的实现一个高效、高性能、异步数据实时刷新的列表/">
                <i class="fa fa-facebook-official"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://silencedut.com/2019/01/24/如何优雅的实现一个高效、高性能、异步数据实时刷新的列表/">
                <i class="fa fa-twitter"></i>
            </a>
        </li>
        
            <li class="post-action">
                <a class="post-action-btn btn btn--default" href="#ds-thread">
                    <i class="fa fa-comment-o"></i>
                </a>
            </li>
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#">
            
                <i class="fa fa-list"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="3">
    <ul class="share-options">
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=http://silencedut.com/2019/01/24/如何优雅的实现一个高效、高性能、异步数据实时刷新的列表/">
                <i class="fa fa-google-plus"></i><span class="">分享到 Google+</span>
            </a>
        </li>
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://silencedut.com/2019/01/24/如何优雅的实现一个高效、高性能、异步数据实时刷新的列表/">
                <i class="fa fa-facebook-official"></i><span>分享到 Facebook</span>
            </a>
        </li>
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=http://silencedut.com/2019/01/24/如何优雅的实现一个高效、高性能、异步数据实时刷新的列表/">
                <i class="fa fa-twitter"></i><span>分享到 Twitter</span>
            </a>
        </li>
    </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.png"/>
        
            <h4 id="about-card-name">SilenceDut</h4>
        
            <h5 id="about-card-bio"><p>talk is cheap,here are my blog</p>
</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android engineer</p>

            </h5>
        
        
            <h5 id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                广东，广州
            </h5>
        
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
    </body>
    <!--SCRIPTS-->
<script src="/assets/js/script-i4qo6jx6jji9fg0dftpya6ivemizsbow4fhow76d8dwpm7m1wbvi378ssumx.min.js"></script>
<!--SCRIPTS END-->

    
        <script type="text/javascript">
            var duoshuoQuery = {short_name:'SilenceDut'};
            (function() {
                var ds = document.createElement('script');
                ds.type = 'text/javascript';ds.async = true;
                ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                ds.charset = 'UTF-8';
                (document.getElementsByTagName('head')[0]
                || document.getElementsByTagName('body')[0]).appendChild(ds);
            })();
        </script>
    



</html>
