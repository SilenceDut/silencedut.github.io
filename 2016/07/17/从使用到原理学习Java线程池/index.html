<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>从使用到原理学习Java线程池 | SilenceDut的代码世界</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="并发的学习与使用系列 第五篇
线程池的技术背景在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。
所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁。如何利用已有对象来服务就是一个需要解决的关键问题，其实这就是一些”池化资">
<meta property="og:type" content="article">
<meta property="og:title" content="从使用到原理学习Java线程池">
<meta property="og:url" content="http://silencedut.com/2016/07/17/从使用到原理学习Java线程池/index.html">
<meta property="og:site_name" content="SilenceDut的代码世界">
<meta property="og:description" content="并发的学习与使用系列 第五篇
线程池的技术背景在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。
所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁。如何利用已有对象来服务就是一个需要解决的关键问题，其实这就是一些”池化资">
<meta property="og:image" content="http://ww3.sinaimg.cn/large/006tKfTcjw1f78gmws5bkj30kh0ib77o.jpg">
<meta property="og:image" content="http://ww4.sinaimg.cn/large/006tKfTcjw1f78hxvv1kmj30nm09c75z.jpg">
<meta property="og:image" content="http://ww2.sinaimg.cn/large/006tKfTcjw1f78hxz9asbj30nm0dm76b.jpg">
<meta property="og:updated_time" content="2016-08-28T04:49:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="从使用到原理学习Java线程池">
<meta name="twitter:description" content="并发的学习与使用系列 第五篇
线程池的技术背景在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。
所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁。如何利用已有对象来服务就是一个需要解决的关键问题，其实这就是一些”池化资">
<meta name="twitter:image" content="http://ww3.sinaimg.cn/large/006tKfTcjw1f78gmws5bkj30kh0ib77o.jpg">
  
    <link rel="alternative" href="/atom.xml" title="SilenceDut的代码世界" type="application/atom+xml">
  
  
     
      <link rel="icon" href="/img/favicon.ico">
    
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/img/avatar.png" class="js-avatar show">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">SilenceDut</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Talk is cheap , here&#39;s my blog</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/SilenceDut" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/concurrent/" style="font-size: 20px;">并发</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">SilenceDut</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img lazy-src="null/img/avatar.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">SilenceDut</h1>
			</hgroup>
			
			<p class="header-subtitle">Talk is cheap , here&#39;s my blog</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/SilenceDut" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-从使用到原理学习Java线程池" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/17/从使用到原理学习Java线程池/" class="article-date">
  	<time datetime="2016-07-17T14:45:29.000Z" itemprop="datePublished">2016-07-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      从使用到原理学习Java线程池
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/concurrent/">并发</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Java/">Java基础</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://silencedut.github.io/2016/07/05/并发的学习与使用">并发的学习与使用系列</a> 第五篇</p>
<h2 id="线程池的技术背景"><a href="#线程池的技术背景" class="headerlink" title="线程池的技术背景"></a>线程池的技术背景</h2><p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。</p>
<p>所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁。如何利用已有对象来服务就是一个需要解决的关键问题，其实这就是一些”池化资源”技术产生的原因。</p>
<p>例如Android中常见到的很多通用组件一般都离不开”池”的概念<a id="more"></a>，如各种图片加载库，网络请求库，即使Android的消息传递机制中的Meaasge当使用Meaasge.obtain()就是使用的Meaasge池中的对象，因此这个概念很重要。本文将介绍的线程池技术同样符合这一思想。</p>
<h2 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h2><ul>
<li><p>重用线程池中的线程,减少因对象创建,销毁所带来的性能开销;</p>
</li>
<li><p>能有效的控制线程的最大并发数,提高系统资源利用率,同时避免过多的资源竞争,避免堵塞;</p>
</li>
<li><p>能够多线程进行简单的管理,使线程的使用简单、高效。</p>
</li>
</ul>
<h2 id="线程池框架Executor"><a href="#线程池框架Executor" class="headerlink" title="线程池框架Executor"></a>线程池框架Executor</h2><p>java中的线程池是通过Executor框架实现的，Executor 框架包括类：Executor，Executors，ExecutorService，ThreadPoolExecutor ，<a href="http://silencedut.com/2016/07/15/Callable%E5%92%8CFuture%E3%80%81FutureTask%E7%9A%84%E4%BD%BF%E7%94%A8/">Future和Callable </a>等。</p>
<p><img src="http://ww3.sinaimg.cn/large/006tKfTcjw1f78gmws5bkj30kh0ib77o.jpg" alt="uml.png"></p>
<p><strong>Executor</strong>: 所有线程池的接口,只有一个方法。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;        </div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>ExecutorService</strong>: 增加Executor的行为，是Executor实现类的最直接接口。</p>
<p><strong>Executors</strong>： 提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService 接口。</p>
<p><strong>ThreadPoolExecutor</strong>：线程池的具体实现类,一般用的各种线程池都是基于这个类实现的。<br>构造方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</div><div class="line">                              <span class="keyword">int</span> maximumPoolSize,</div><div class="line">                              <span class="keyword">long</span> keepAliveTime,</div><div class="line">                              TimeUnit unit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</div><div class="line">                              </div><div class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</div><div class="line">             Executors.defaultThreadFactory(), defaultHandler);</div><div class="line">             </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><strong>corePoolSize</strong>：线程池的核心线程数,线程池中运行的线程数也永远不会超过 corePoolSize 个,默认情况下可以一直存活。可以通过设置allowCoreThreadTimeOut为True,此时 <strong>核心线程数就是0</strong>,此时keepAliveTime控制所有线程的超时时间。</p>
</li>
<li><p><strong>maximumPoolSize</strong>：线程池允许的最大线程数;</p>
</li>
<li><p><strong>keepAliveTime</strong>： 指的是空闲线程结束的超时时间;</p>
</li>
<li><p><strong>unit</strong> ：是一个枚举，表示 keepAliveTime 的单位;</p>
</li>
<li><p><strong>workQueue</strong>：表示存放任务的BlockingQueue&lt;Runnable队列。</p>
</li>
</ul>
<p><strong>BlockingQueue</strong></p>
<p>阻塞队列（BlockingQueue）是java.util.concurrent下的主要用来控制线程同步的工具。如果BlockQueue是空的,从BlockingQueue取东西的操作将会被阻断进入等待状态,直到BlockingQueue进了东西才会被唤醒。同样,如果BlockingQueue是满的,任何试图往里存东西的操作也会被阻断进入等待状态,直到BlockingQueue里有空间才会被唤醒继续操作。<br>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。具体的实现类有LinkedBlockingQueue,ArrayBlockingQueued等。一般其内部的都是通过Lock和Condition(<a href="2016/07/12/显示锁（Lock）及Condition的学习与使用/">显示锁（Lock）及Condition的学习与使用</a>)来实现阻塞和唤醒。</p>
<p><strong>线程池的工作过程如下：</strong></p>
<ol>
<li><p>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</p>
</li>
<li><p>当调用 execute() 方法添加一个任务时，线程池会做如下判断：</p>
<ul>
<li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；   </li>
<li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li>
<li>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li>
<li>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。</li>
</ul>
</li>
<li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行。</p>
</li>
<li><p>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p>
</li>
</ol>
<h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><p>生成线程池采用了工具类Executors的静态方法，以下是几种常见的线程池。</p>
<p><strong>SingleThreadExecutor</strong>：单个后台线程  (其缓冲队列是无界的)  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;        </div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService (</div><div class="line">        <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,                                    </div><div class="line">        <span class="number">0L</span>, TimeUnit.MILLISECONDS,                                    </div><div class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建一个单线程的线程池。这个线程池只有一个核心线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
<p><strong>FixedThreadPool</strong>：只有核心线程的线程池,大小固定 (其缓冲队列是无界的) 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;         </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,                                       </div><div class="line">            <span class="number">0L</span>, TimeUnit.MILLISECONDS,                                         </div><div class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());     </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。    </p>
<p><strong>CachedThreadPool</strong>：无界线程池，可以进行自动线程回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;         </div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>,Integer.MAX_VALUE,                                           </div><div class="line">           <span class="number">60L</span>, TimeUnit.SECONDS,                                       </div><div class="line">           <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());     </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。SynchronousQueue是一个是缓冲区为1的阻塞队列。  </p>
<p>ScheduledThreadPool：核心线程池固定，大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;         </div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPool(corePoolSize, </div><div class="line">              Integer.MAX_VALUE,                                                  </div><div class="line">              DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,                                                    </div><div class="line">              <span class="keyword">new</span> DelayedWorkQueue());    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建一个周期性执行任务的线程池。如果闲置,非核心线程池会在DEFAULT_KEEPALIVEMILLIS时间内回收。</p>
<h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><p>线程池最常用的提交任务的方法有两种：</p>
<p><strong>execute</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ExecutorService.execute(Runnable runable)；</div></pre></td></tr></table></figure>
<p><strong>submit</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">FutureTask task = ExecutorService.submit(Runnable runnable);</div><div class="line">	</div><div class="line">FutureTask&lt;T&gt; task = ExecutorService.submit(Runnable runnable,T Result);</div><div class="line">	</div><div class="line">FutureTask&lt;T&gt; task = ExecutorService.submit(Callable&lt;T&gt; callable);</div></pre></td></tr></table></figure>
<p>submit(Callable callable)的实现，submit(Runnable runnable)同理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    FutureTask&lt;T&gt; ftask = newTaskFor(task);</div><div class="line">    execute(ftask);</div><div class="line">    <span class="keyword">return</span> ftask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出submit开启的是有返回结果的任务，会返回一个FutureTask对象，这样就能通过get()方法得到结果。submit最终调用的也是execute(Runnable runable)，submit只是将Callable对象或Runnable封装成一个FutureTask对象，因为FutureTask是个Runnable，所以可以在execute中执行。关于Callable对象和Runnable怎么封装成FutureTask对象，见<a href="2016/07/15/Callable和Future、FutureTask的使用/">Callable和Future、FutureTask的使用</a>。</p>
<h2 id="线程池实现的原理"><a href="#线程池实现的原理" class="headerlink" title="线程池实现的原理"></a>线程池实现的原理</h2><p>如果只讲线程池的使用，那这篇博客没有什么大的价值，充其量也就是熟悉Executor相关API的过程。线程池的实现过程没有用到Synchronized关键字，用的都是volatile,Lock和同步(阻塞)队列,Atomic相关类，FutureTask等等，因为后者的性能更优。理解的过程可以很好的学习源码中并发控制的思想。</p>
<p>在开篇提到过线程池的优点是可总结为以下三点：</p>
<ol>
<li>线程复用</li>
<li>控制最大并发数</li>
<li>管理线程</li>
</ol>
<h4 id="1-线程复用过程"><a href="#1-线程复用过程" class="headerlink" title="1.线程复用过程"></a>1.线程复用过程</h4><p><strong>理解线程复用原理首先应了解线程生命周期。</strong></p>
<p><img src="http://ww4.sinaimg.cn/large/006tKfTcjw1f78hxvv1kmj30nm09c75z.jpg" alt="Life Cycle.png"></p>
<p>在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态。</p>
<p>Thread通过new来新建一个线程，这个过程是是初始化一些线程信息，如线程名，id,线程所属group等，可以认为只是个普通的对象。调用Thread的start()后Java虚拟机会为其创建方法调用栈和程序计数器，同时将hasBeenStarted为true,之后调用start方法就会有异常。</p>
<p>处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。当线程获取cpu后，run()方法会被调用。不要自己去调用Thread的run()方法。之后根据CPU的调度在就绪——运行——阻塞间切换，直到run()方法结束或其他方式停止线程，进入dead状态。</p>
<p>所以实现线程复用的原理应该就是要保持线程处于存活状态（就绪，运行或阻塞）。接下来来看下ThreadPoolExecutor是怎么实现线程复用的。</p>
<p>在ThreadPoolExecutor主要Worker类来控制线程的复用。看下Worker类简化后的代码，这样方便理解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"> </div><div class="line">	<span class="keyword">final</span> Thread thread;</div><div class="line">    </div><div class="line">	Runnable firstTask;</div><div class="line">    </div><div class="line">	Worker(Runnable firstTask) &#123;</div><div class="line">        <span class="keyword">this</span>.firstTask = firstTask;</div><div class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        runWorker(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</div><div class="line">		Runnable task = w.firstTask;</div><div class="line">		w.firstTask = <span class="keyword">null</span>;    </div><div class="line">		        	</div><div class="line">		<span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>)&#123;</div><div class="line">			task.run();</div><div class="line">    	&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Worker是一个Runnable,同时拥有一个thread，这个thread就是要开启的线程，在新建Worker对象时同时新建一个Thread对象，同时将Worker自己作为参数传入TThread，这样当Thread的start()方法调用时，运行的实际上是Worker的run()方法，接着到runWorker()中,有个while循环，一直从getTask()里得到Runnable对象，顺序执行。getTask()又是怎么得到Runnable对象的呢？</p>
<p>依旧是简化后的代码：</p>
<pre><code class="java"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>{
    <span class="keyword">if</span>(一些特殊情况) {
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }

    Runnable r = workQueue.take();

    <span class="keyword">return</span> r;
}
</code></pre>
<p>这个workQueue就是初始化ThreadPoolExecutor时存放任务的BlockingQueue<Runnable>队列，这个队列里的存放的都是将要执行的Runnable任务。因为BlockingQueue是个阻塞队列，BlockingQueue.take()得到如果是空，则进入等待状态直到BlockingQueue有新的对象被加入时唤醒阻塞的线程。所以一般情况Thread的run()方法就不会结束,而是不断执行从workQueue里的Runnable任务，这就达到了线程复用的原理了。</p>
<h3 id="2-控制最大并发数"><a href="#2-控制最大并发数" class="headerlink" title="2.控制最大并发数"></a>2.控制最大并发数</h3><p>那workQueue是什么时候放入Runnable？Worker又是什么时候创建，Worker里的Thread的又是什么时候调用start()开启新线程来执行Worker的run()方法的呢？有上面的分析看出Worker里的runWorker()执行任务时是一个接一个，串行进行的，那并发是怎么体现的呢？</p>
<p>很容易想到是在execute(Runnable runnable)时会做上面的一些任务。看下execute里是怎么做的。</p>
<p><strong>execute():</strong></p>
<p>简化后的代码</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>{
    <span class="keyword">if</span> (command == <span class="keyword">null</span>)
        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();

    <span class="keyword">int</span> c = ctl.get();

    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) {
        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))
            <span class="keyword">return</span>; 
        c = ctl.get();
    }

    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) {
        <span class="keyword">int</span> recheck = ctl.get();
        <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)
            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);
            } <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))
        reject(command);
    }
}
</code></pre>
<p><strong>addWorker():</strong></p>
<p>简化后的代码</p>
<pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>{

    <span class="keyword">int</span> wc = workerCountOf(c);
    <span class="keyword">if</span> (wc &gt;= (core ? corePoolSize : maximumPoolSize)) {
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    w = <span class="keyword">new</span> Worker(firstTask);
    <span class="keyword">final</span> Thread t = w.thread;
    t.start();
}
</code></pre>
<p><strong>corePoolSize</strong>，当执行一个任务时如果当前的线程数小于核心线程数，则调用addWorker(command, true)，表示将要创建核心线程，在addWorker()中判断如果核心线程已经达到最大，则返回false,无法创建新的Worker也就是线程。如果创建成功则通过start()开启新线程，同时将firstTask作为这个Worker里的run()中执行的第一个任务,这也是核心线程创建时可以立刻执行任务的原因。</p>
<p>如果核心线程已满，通过addWorker(command, false)，尝试创建非核心线程，如果此时线程已达到最大如果添加失败，则进行拒绝策略处理。如果成功则和上面的过程一样。<br>这个过程里<strong>workQueue.offer(command)</strong>就是将Runnable放进阻塞队列workQueue里，等待其取出执行，所以非核心线程的任务<strong>可能</strong>不是立刻执行。为什么说可能呢？因为如果addWorker(command, false)创建成功了，也会立刻执行的。</p>
<p>虽然每个Worker的任务是串行处理，但如果创建了多个Worker，因为共用一个workQueue，所以就会并行处理了。</p>
<p>所以根据corePoolSize和maximumPoolSize来控制最大并发数。大致过程可用下图表示。</p>
<p><img src="http://ww2.sinaimg.cn/large/006tKfTcjw1f78hxz9asbj30nm0dm76b.jpg" alt=""></p>
<p>可以结合上面的讲解和图来理解这个过程。</p>
<p>###3. 管理线程<br>通过线程池可以很好的管理线程的复用，控制并发数，以及销毁等过程。这个过程最好理解。线程的复用和控制并发上面已经讲了，这里通过shutdown和shutdownNow()来分析线程池的关闭过程。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/07/15/Callable和Future、FutureTask的使用/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Callable和Future、FutureTask的使用</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="从使用到原理学习Java线程池" data-title="从使用到原理学习Java线程池" data-url="http://silencedut.com/2016/07/17/从使用到原理学习Java线程池/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 SilenceDut
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: '/'
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>
	(function(){
		document.write('<scr'+'ipt type="text/javascript" src="'+document.location.protocol+'//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">'+'</sc'+'ript>');
	})();
</script>


  </div>
</body>
</html>