
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="SilenceDut的代码世界">
    <title>由ReentrantLock分析JUC的核心AQS - SilenceDut的代码世界</title>
    <meta name="author" content="SilenceDut">
    
    
        <link rel="icon" href="http://silencedut.com/assets/images/avatar.png">
    
    
    <meta name="description" content="并发的学习与使用系列 第八篇
AQS是AbstractQueuedSynchronizer的简称，是并发组件包java.util.concurrent也就是JUC(Java Util Concurrency)的核心，以及很多并发组件如前面几篇中介绍到的ReentrantLock，Condition,BlockingQueue以及线程池里使用的worker等都是基于其实现的，将很多复杂的，繁琐的并发">
<meta property="og:type" content="blog">
<meta property="og:title" content="由ReentrantLock分析JUC的核心AQS">
<meta property="og:url" content="http://silencedut.com/2017/01/09/由ReentrantLock分析JUC的核心AQS/index.html">
<meta property="og:site_name" content="SilenceDut的代码世界">
<meta property="og:description" content="并发的学习与使用系列 第八篇
AQS是AbstractQueuedSynchronizer的简称，是并发组件包java.util.concurrent也就是JUC(Java Util Concurrency)的核心，以及很多并发组件如前面几篇中介绍到的ReentrantLock，Condition,BlockingQueue以及线程池里使用的worker等都是基于其实现的，将很多复杂的，繁琐的并发">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006y8lVajw1fblbiaodhcj30qo046wei.jpg">
<meta property="og:updated_time" content="2017-01-13T06:17:31.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="由ReentrantLock分析JUC的核心AQS">
<meta name="twitter:description" content="并发的学习与使用系列 第八篇
AQS是AbstractQueuedSynchronizer的简称，是并发组件包java.util.concurrent也就是JUC(Java Util Concurrency)的核心，以及很多并发组件如前面几篇中介绍到的ReentrantLock，Condition,BlockingQueue以及线程池里使用的worker等都是基于其实现的，将很多复杂的，繁琐的并发">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/006y8lVajw1fblbiaodhcj30qo046wei.jpg">
    
    
        
    
    
        <meta property="og:image" content="http://silencedut.com/assets/images/avatar.png"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-nuvue6sithwirecbhvw3dkaobiojqvtadsnhguwi7k04xklybw5djl1smadp.min.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


<header id="header" data-behavior="3">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/ ">SilenceDut的代码世界</a>
    </h1>
    
        
            <a  class="header-right-icon "
                href="#about">
        
        
            <i class="fa fa-lg fa-avatar.png"></i>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="3">
    
        <div class="sidebar-profile">
            <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.png"/>
            </a>
            <span class="sidebar-profile-name">SilenceDut</span>
        </div>
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/ "
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">首页</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-archives"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                    <span class="sidebar-button-desc">归档</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">标签</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://github.com/SilenceDut" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                    <span class="sidebar-button-desc">GitHub</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="mailto:silencedutchman@foxmail.com" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                    <span class="sidebar-button-desc">邮箱</span>
                </a>
        </li>
        
    </ul>
    
</nav>

            
            <div id="main" data-behavior="3"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post" itemscope itemType="http://schema.org/BlogPosting">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title" itemprop="headline">
            由ReentrantLock分析JUC的核心AQS
        </h1>
    
    <div class="post-meta">
    <time itemprop="datePublished" datetime="2017-01-09T21:22:24+08:00">
	
		    1月 09, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/all-categories/Java/">Java</a>


    
</div>

</div>
    
    <div class="post-content markdown" itemprop="articleBody">
        <div class="main-content-wrap">
            <p><a href="http://www.silencedut.com/2016/06/03/并发的学习与使用">并发的学习与使用系列</a> 第八篇</p>
<p>AQS是AbstractQueuedSynchronizer的简称，是并发组件包java.util.concurrent也就是JUC(Java Util Concurrency)的核心，以及很多并发组件如前面几篇中介绍到的ReentrantLock，Condition,BlockingQueue以及线程池里使用的worker等都是基于其实现的，将很多复杂的，繁琐的并发控制过程封装起来，便于其他并发工具类来实现更多，方便的功能，其主要通过volatile和UnSafe类的原子操作（Atomic相关）来实现阻塞和同步，这里通过ReentrantLock来分析下AQS的实现原理。</p>
<a id="more"></a>
<h2 id="ReentrantLock的实现原理"><a href="#ReentrantLock的实现原理" class="headerlink" title="ReentrantLock的实现原理"></a>ReentrantLock的实现原理</h2><p>之前的文章<a href="http://www.silencedut.com/2016/06/12/显示锁（Lock）及Condition的学习与使用">并发的学习与使用系列</a>提到里Lock的实现类ReentrantLock是一个可重入的，可实现公平的锁。下面通过ReentrantLock的源码来看看其是怎么实现的。</p>
<h3 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h3><p>AbstractQueuedSynchronizer是一个抽象类，其他类主要通过重载其tryAcquire(int arg)来获取锁通过tryRealese()来释放锁。</p>
<h3 id="非公平锁获取锁的过程"><a href="#非公平锁获取锁的过程" class="headerlink" title="非公平锁获取锁的过程"></a>非公平锁获取锁的过程</h3><p>ReentrantLock的默认构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync = <span class="keyword">new</span> NonfairSync();</div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</div><div class="line">...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Sync是ReentrantLock实现公平与非公平锁的主要实现，所以默认请况下ReentrantLock是个非公平锁。一般通过ReentrantLock.lock()来获取锁，其实现是在Sync中完成的。下面是先以非公平锁的实现方式来分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">NoFairSync类</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">       setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">    <span class="keyword">else</span></div><div class="line">       acquire(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">AQS类</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</div><div class="line">    <span class="comment">// See below for intrinsics setup to support this</span></div><div class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>compareAndSetState(0, 1)是一个原子操作，其代表的是如果原来的值是0那就将其设为1，并且返回ture。那这个原来的值是指的谁的值呢？从compareAndSetState中并看不出来。那就从整体来看，在AQS中有个表示当前锁的状态的int值state,当state等于0时，表示锁可用，否则表示锁定状态，是否可用还需考虑其他情况如可重入性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</div></pre></td></tr></table></figure>
<p>可以想到compareAndSetState(0, 1)应该就是设置这个state的状态，其实现原理是通过Unsafe类可直接操作内存的特性来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe =Unsafe.getUnsafe(）;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</div><div class="line"></div><div class="line">stateOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">"state"</span>));</div></pre></td></tr></table></figure>
<p>所以这样就很好理解了，通过Unsafe直接得到state的内存地址然后直接错作内存，因为直接可以控制内存值，这也是Unsafe类名字的来源，后面还会介绍其改进。</p>
<p>在回来分析lock()，如果设置状态成功，也就是成功获取了锁，接下来是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setExclusiveOwnerThread(Thread.currentThread());</div><div class="line"></div><div class="line">AQS类中</div><div class="line">exclusiveOwnerThread = thread;</div></pre></td></tr></table></figure>
<p>表示当前exclusiveOwnerThread占据着该锁，可重入性的实现就与其有关，后面介绍。这时就可以直接执行lock()后面的程序了。</p>
<p>如果获取锁失败进入AQS的acquire(int arg);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>tryAcquire实在NonfairSync中实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">NonfairSync：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个过程是先去判断锁的状态是否为可用，如果锁已被持有，则再判断持有锁的线程是否未当前线程，如果是则将锁的持有递增，这也是java层实现可重入性的原理。如果再次失败，则进入等待队列。</p>
<p><img src="http://ww1.sinaimg.cn/large/006y8lVajw1fblbiaodhcj30qo046wei.jpg" alt=""></p>
<p>通过类Node来实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;  </div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();  </div><div class="line">   </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;  </div><div class="line">  </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;  </div><div class="line">    </div><div class="line">    <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span>  </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;  </div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;  </div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;  </div><div class="line">  </div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;  </div><div class="line">  </div><div class="line">    <span class="keyword">volatile</span> Node prev;  </div><div class="line">  </div><div class="line">    <span class="keyword">volatile</span> Node next;  </div><div class="line">  </div><div class="line">    <span class="keyword">volatile</span> Thread thread;  </div><div class="line">  </div><div class="line">    Node nextWaiter;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> nextWaiter == SHARED;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;  </div><div class="line">        Node p = prev;  </div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </div><div class="line">        <span class="keyword">else</span>  </div><div class="line">            <span class="keyword">return</span> p;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker  </span></div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter  </span></div><div class="line">        <span class="keyword">this</span>.nextWaiter = mode;  </div><div class="line">        <span class="keyword">this</span>.thread = thread;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition  </span></div><div class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;  </div><div class="line">        <span class="keyword">this</span>.thread = thread;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AQS的线程阻塞队列是个双向队列，提供了FIFO先来先服务的公平性，用head节点表示对首，tail表示队尾。</p>
<ol>
<li><p>节点Node维护一个volatile状态，维护一个prev指针指向前一个节点，根据前一个节点的状态来判断是否可获取锁</p>
</li>
<li><p>当线程释放锁时，只需要修改自身状态即可，后续节点会观察到volatile状态的改动而获取锁</p>
</li>
</ol>
<p>接着看下获取锁失败后进入队列的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</div><div class="line"></div><div class="line"><span class="comment">//将新的节点加入到队尾</span></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</div><div class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</div><div class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></div><div class="line">    Node pred = tail;</div><div class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</div><div class="line">        node.prev = pred;</div><div class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</div><div class="line">            pred.next = node;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    enq(node);</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>未获取到锁将新建一个Node节点，然后将其加入到队尾，此时并未有将其阻塞，在acquireQueued中将再次尝试获取锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="comment">//判断前一个节点是否为头节点并且成功过去了锁，如果是将当前节点设为头结点，也就是说明队列的头结点就是当前获取锁的线程，可以看出一个节点是否能获取锁只和他前面的节点有关</span></div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">       			parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</div><div class="line">       </div><div class="line">        <span class="comment">//如果其前节点当前属于等待被唤醒的状态，返回值代表可以将当前节点阻塞。</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">//如果其前节点已取消，则向前继续找知道找到状态不是CANCELLED的作为新的前节点。</span></div><div class="line">        do &#123;</div><div class="line">            node.prev = pred = pred.prev;</div><div class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">        pred.next = node;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//前节点状态是0（不要和AQS的锁的状态state弄混），或者其他状态，先将其前节点置为Node.SIGNAL，此时不阻塞，待下次循环中确认</span></div><div class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//如果shouldParkAfterFailedAcquire（）返回false,及当且只有其前节点pred状态为Node.SIGNAL时，将当前节点node阻塞</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">    LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> Thread.interrupted();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">LockSupport.java类：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    <span class="comment">//这里记录线程阻塞在的对象，便于调试用</span></div><div class="line">    setBlocker(t, blocker);</div><div class="line">    </div><div class="line">    <span class="comment">//此步骤为将当前线程阻塞</span></div><div class="line">    unsafe.park(<span class="keyword">false</span>, <span class="number">0L</span>);</div><div class="line">    setBlocker(t, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>jdk中unsafe.park调用native方法将线程阻塞，而在Android sdk中有不同的实现方式，后续介绍。</p>
<p>以上就是ReentrantLock的非公平锁调用lock()过程，首先去尝试改变AQS设为state的状态，改变成功就获取了锁，失败后再次通过判断当前的state是否为0，即未锁定状态，再次尝试改变state状态获取锁，如果state不为0，即锁已经被其他线程持有，则判断当前线程是不是已经持有该锁，如果是，则获取锁成功，且锁的次数增加。否则加入到Node队列，加入队列后在在for循环中通过判断其前节点的状态来决定是否需要阻塞，<strong>可以看出在加入队列前及阻塞前多次尝试去获取锁，而避免进入线程阻塞，这是因为阻塞、唤醒都需要cpu的调度，以及上下文切换，这是个重量级的操作，应尽量避免</strong>。</p>
<h3 id="公平锁获取锁的过程"><a href="#公平锁获取锁的过程" class="headerlink" title="公平锁获取锁的过程"></a>公平锁获取锁的过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">FairSync类：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">//先去判断锁的状态，而不是直接去获取</span></div><div class="line">	acquire(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">AQS类：</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">FairSync类：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//hasQueuedPredecessors判断是否有前节点，如果有就不会尝试去获取锁</span></div><div class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</div><div class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看下实现过程，和非公平锁很相似，主要差别lock()的时候不是直接去获取锁，而是先看锁是否可用并且没有前节点，有前节点的话，即使锁是空闲也不会获取锁。</p>
<h3 id="释放锁的过程"><a href="#释放锁的过程" class="headerlink" title="释放锁的过程"></a>释放锁的过程</h3><p>公平锁和非公平锁的释放过程是一样的，其实现都是在Sync父类中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">	sync.release(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">            unparkSuccessor(h);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> c = getState() - releases;</div><div class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        free = <span class="keyword">true</span>;</div><div class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    setState(c);</div><div class="line">    <span class="keyword">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码很好理解，就是先去改变AQS的中代表锁状态的state值，改变后如果state为0，说明没有线程持有该锁，因为是可重入的，所以如果之前一个线程多次获取该锁，也需要释放多次。</p>
<p>锁释放后并没有唤醒之前阻塞的线程，所以还需要后续的唤醒操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="comment">//改变头结点的值，对唤醒后续节点没影响.</span></div><div class="line">	<span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">	<span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">	    compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line">	</div><div class="line">	Node s = node.next;</div><div class="line">	<span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">	    s = <span class="keyword">null</span>;</div><div class="line">	    <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line">	        <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">	            s = t;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">	    LockSupport.unpark(s.thread);</div><div class="line">&#125;</div><div class="line"></div><div class="line">LockSupport类：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</div><div class="line">        unsafe.unpark(thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从lock()的过程可知，Head节点就是当前持有锁的线程节点，当释放锁时，从头结点的next来看，头结点的下一个节点如果不为null,且waitStatus不大于0，则跳过判断，否则从队尾向前找到最前的一个waitStatus的节点，然后通过LockSupport.unpark(s.thread)唤醒该节点线程。可以看出ReentrantLock的非公平锁只是在获取锁的时候是非公平的，如果进入到等待队列后，在head节点的线程unlock()时，会按照进入的顺序来得到唤醒，保证了队列的FIFO的特性。</p>
<h3 id="AQS总结"><a href="#AQS总结" class="headerlink" title="AQS总结"></a>AQS总结</h3><h4 id="ReentrantLock和synchronized的选择"><a href="#ReentrantLock和synchronized的选择" class="headerlink" title="ReentrantLock和synchronized的选择"></a>ReentrantLock和synchronized的选择</h4><p>可以看出无论是获取锁还是释放锁的时候锁最多只有两个线程在竞争，而其他情况下，阻塞的线程不会被唤醒参与竞争，所以性能较高，因为阻塞和唤醒都是需要上下文切换，同时多个线的程竞争都会使CPU占用率升高，降低吞吐量。内置锁在最初的jdk版本中会有这个情况，但后续逐渐优化，所以选择ReentrantLock和synchronized的条件不应该是主要原因，而是应该考虑锁是否需要公平性，是否需要可中断，可共享等来作为选择依据。</p>
<h4 id="有趣的Unsafe类"><a href="#有趣的Unsafe类" class="headerlink" title="有趣的Unsafe类"></a>有趣的Unsafe类</h4><p>为什么叫Unsafe类呢？也就是不安全的，因为Unsafe类可以直接操作内存，这对java安全性是一个隐患,据说后续会逐渐改变其实现方式，而在Android的sdk-23中，Unsafe类已经有些改变了，Thread也和jdk的不同，之前通过unsafe.park()的native方法来阻塞一个线程，unsafe.unpark()来唤醒，而在Android中unsafe.park()会调用Thread的park方法，而Thread的park其实又会调用其wait()，这下就清晰了，就和普通的对象的wait()一样，然后unsafe.unpark()最终会调用到notify()方法。</p>
<p>所以源码一直实在变化的，尤其Android sdk和jdk也有一些区别，但掌握其思想就能很好的理解并掌握新的变化。这也是这一年来在做的，放下浮躁的心态，扎实基础，掌握原理。</p>

            
        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/concurrent/">并发</a> <a class="tag tag--primary tag--small t-link" href="/tags/sourceCode/">源码分析</a>

            </div>
        
        <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--disabled">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2016/12/14/关于Java GC的理解/" data-tooltip="关于Java GC的理解">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://silencedut.com/2017/01/09/由ReentrantLock分析JUC的核心AQS/">
                <i class="fa fa-google-plus"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://silencedut.com/2017/01/09/由ReentrantLock分析JUC的核心AQS/">
                <i class="fa fa-facebook-official"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://silencedut.com/2017/01/09/由ReentrantLock分析JUC的核心AQS/">
                <i class="fa fa-twitter"></i>
            </a>
        </li>
        
            <li class="post-action">
                <a class="post-action-btn btn btn--default" href="#ds-thread">
                    <i class="fa fa-comment-o"></i>
                </a>
            </li>
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#">
            
                <i class="fa fa-list"></i>
            </a>
        </li>
    </ul>
</div>


        
            
                <div id="ds-thread" class="ds-thread" data-thread-key="2017/01/09/由ReentrantLock分析JUC的核心AQS/"
     data-title="由ReentrantLock分析JUC的核心AQS" data-url="http://silencedut.com/2017/01/09/由ReentrantLock分析JUC的核心AQS/">
</div>

            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 SilenceDut. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="3">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--disabled">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2016/12/14/关于Java GC的理解/" data-tooltip="关于Java GC的理解">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://silencedut.com/2017/01/09/由ReentrantLock分析JUC的核心AQS/">
                <i class="fa fa-google-plus"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://silencedut.com/2017/01/09/由ReentrantLock分析JUC的核心AQS/">
                <i class="fa fa-facebook-official"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://silencedut.com/2017/01/09/由ReentrantLock分析JUC的核心AQS/">
                <i class="fa fa-twitter"></i>
            </a>
        </li>
        
            <li class="post-action">
                <a class="post-action-btn btn btn--default" href="#ds-thread">
                    <i class="fa fa-comment-o"></i>
                </a>
            </li>
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#">
            
                <i class="fa fa-list"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="3">
    <ul class="share-options">
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=http://silencedut.com/2017/01/09/由ReentrantLock分析JUC的核心AQS/">
                <i class="fa fa-google-plus"></i><span class="">分享到 Google+</span>
            </a>
        </li>
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://silencedut.com/2017/01/09/由ReentrantLock分析JUC的核心AQS/">
                <i class="fa fa-facebook-official"></i><span>分享到 Facebook</span>
            </a>
        </li>
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=http://silencedut.com/2017/01/09/由ReentrantLock分析JUC的核心AQS/">
                <i class="fa fa-twitter"></i><span>分享到 Twitter</span>
            </a>
        </li>
    </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.png"/>
        
            <h4 id="about-card-name">SilenceDut</h4>
        
            <h5 id="about-card-bio"><p>talk is cheap,here are my blog</p>
</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android engineer</p>

            </h5>
        
        
            <h5 id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                广东，广州
            </h5>
        
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
    </body>
    <!--SCRIPTS-->
<script src="/assets/js/script-i4qo6jx6jji9fg0dftpya6ivemizsbow4fhow76d8dwpm7m1wbvi378ssumx.min.js"></script>
<!--SCRIPTS END-->

    
        <script type="text/javascript">
            var duoshuoQuery = {short_name:'SilenceDut'};
            (function() {
                var ds = document.createElement('script');
                ds.type = 'text/javascript';ds.async = true;
                ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                ds.charset = 'UTF-8';
                (document.getElementsByTagName('head')[0]
                || document.getElementsByTagName('body')[0]).appendChild(ds);
            })();
        </script>
    



</html>
