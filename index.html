
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="SilenceDut的代码世界">
    <title>SilenceDut的代码世界</title>
    <meta name="author" content="SilenceDut">
    
    
        <link rel="icon" href="http://silencedut.com/assets/images/avatar.png">
    
    
    <meta name="description" content="SilenceDut">
<meta property="og:type" content="blog">
<meta property="og:title" content="SilenceDut的代码世界">
<meta property="og:url" content="http://silencedut.com/index.html">
<meta property="og:site_name" content="SilenceDut的代码世界">
<meta property="og:description" content="SilenceDut">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SilenceDut的代码世界">
<meta name="twitter:description" content="SilenceDut">
    
    
        
    
    
        <meta property="og:image" content="http://silencedut.com/assets/images/avatar.png"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-nuvue6sithwirecbhvw3dkaobiojqvtadsnhguwi7k04xklybw5djl1smadp.min.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/ ">SilenceDut的代码世界</a>
    </h1>
    
        
            <a  class="header-right-icon "
                href="#about">
        
        
            <i class="fa fa-lg fa-avatar.png"></i>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    
        <div class="sidebar-profile">
            <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.png"/>
            </a>
            <span class="sidebar-profile-name">SilenceDut</span>
        </div>
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/ "
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">首页</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">标签</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://github.com/SilenceDut" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                    <span class="sidebar-button-desc">GitHub</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="mailto:silencedutchman@foxmail.com" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                    <span class="sidebar-button-desc">邮箱</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="http://www.itvincent.net/" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                    <span class="sidebar-button-desc">itvincent</span>
                </a>
        </li>
        
    </ul>
    
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                

<section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2019/01/24/如何优雅的实现一个高效、高性能、异步数据实时刷新的列表/">
                            如何优雅的实现一个高效、高性能、异步数据实时刷新的列表
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2019-01-24T02:22:24+08:00">
	
		    1月 24, 2019
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/all-categories/Android/">Android</a>, <a class="category-link" href="/all-categories/Android/OpenSourceProject/">OpenSourceProject</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>Android的业务开发中。列表需求很很常见也很重要的部分，列表承载的信息多，涉及的的协议多，布局也多，尤其一些复杂的列表，不管是用ListView还是RecyclerView，使用不当会带来很多的性能问题和后期的维护问题，形成一套规范的，高性能的列表开发模式很有必要。</p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>用一些案例说明一下吧(只是用一些App里的截图来做类比，并不知其协议类型和实现方式)<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fyx83bvbyjj30py0wu4az.jpg" alt=""></p>
<p>类似的列表不容易解决的主要在两个方面：</p>
<ol>
<li><p>先不管列表里每个Item的具体UI,首先列表是可通过下拉刷新和广播通知变化，数据应该也只能全量下发，更新频率可能特别高，列表的长度也可能很长比如几百条（一些聊天列表或者在线用户列表可能存在数据量更大的情况）,如果过高频率的刷新很容易造成页面卡顿。</p>
</li>
<li><p>从UI上看有很多特征，昵称、头像、等级、各种特权等等，而且大部分情况一条协议是无法包含所有信息，可能是很多个版本需求的迭代，涉及到多个协议，比如我们项目中这种情况大部分是只返回一些uid列表，一般先将基本的数据设置到adapter里显示，同时根据uid去查询相应的各个对应的协议，异步返回结果，然后更新对应的Item，<strong>因为都是异步的数据很难先拼接好数据再更新列表</strong>。还有些情况是Item中的一些数据可能会根据通知出现变化，比如等级升级了，离开了。或者，如下图常见的聊天列表根据通知更新数据的：<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fz8y3v6fyhj30u00i2400.jpg" alt=""><br>在线状态，最新的聊天内容，时间，未读消息数等，如果item中可变的数据太多，更新的代码写起来会很繁琐。</p>
</li>
</ol>
<h2 id="列表的性能问题"><a href="#列表的性能问题" class="headerlink" title="列表的性能问题"></a>列表的性能问题</h2><p>使用过页面卡顿工具<a href="https://developer.android.com/studio/command-line/systrace">systrace</a>分析页面卡顿或者超时的应该有一定的经验就是如果页面存在比较复杂的列表，在一些低端机，有的甚至配置较好的手机上会出现卡顿情况，及时感觉不到卡顿，用<a href="https://developer.android.com/studio/command-line/systrace">systrace</a>应该也能看到相对其他View比较多的掉帧（也可称为Jank），谷歌根据比较多的一些app的数据也有类似的结论，列表的使用不当是很多卡顿的来源<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fyxa6v140cj31eo0i6wj5.jpg" alt=""></p>
<p>列表容易造成卡顿主要原因是相对其他View，列表承载的内容多，更新又比较频繁，而且还有hodelr的的重建复用以及无效刷新等带来的很多的子Item View的UI刷新,列表变化频繁(如删除、移动、新增等)，动画会带来很大的UI性能消耗,根据原因主要从下面几个个方面来提高列表的性能：</p>
<ul>
<li>即使调用再多次notifyData，列表内容不变化的时候不刷新UI，内容变化的时候只刷新需要UI更新的Item</li>
<li>列表内容相关的异步数据或者通知需要更新列表时高效更新</li>
<li>根据具体情形，可以禁用列表的动画。</li>
</ul>
<h2 id="不易用的DiffUtil"><a href="#不易用的DiffUtil" class="headerlink" title="不易用的DiffUtil"></a>不易用的DiffUtil</h2><p>DiffUtil是support-v7:24.2.0中的新工具类，它用来比较两个数据集，寻找出旧数据集-》新数据集的最小变化量。并不是一个新的工具，这里如果只是介绍如何使用DiffUtil也没任何意义。DiffUtil虽然提供很久，能高性能的刷新列表，但是其使用情况上来看，可能并不理想，主要原因是：<strong>非常不易使用</strong></p>
<ul>
<li><p><strong>写起来麻烦：</strong> 使用时需要实现DiffCallBack抽象类，需要实现至少四个方法这样即使一个很简单的列表也要写上很多的代码，如果列表里有多种Type的Holder,写起来就更加的臃肿耦合，</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Callback</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Callback</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getOldListSize</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getNewListSize</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">areItemsTheSame</span><span class="params">(<span class="keyword">int</span> var1, <span class="keyword">int</span> var2)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">areContentsTheSame</span><span class="params">(<span class="keyword">int</span> var1, <span class="keyword">int</span> var2)</span></span>;</div><div class="line"></div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getChangePayload</span><span class="params">(<span class="keyword">int</span> oldItemPosition, <span class="keyword">int</span> newItemPosition)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><span id = "jump1">     </p>
</li>
<li><strong>容易崩溃：</strong> DiffCallBack计算数据差量时需要放到异步线程，稍有不慎容易崩溃，<br>  <code>java.lang.IndexOutOfBoundsException,Inconsistency detected. Invalid view holder adapter positionViewHolder{65752ee position=2 id=-1, oldPos=2, pLpos:2 scrap [attachedScrap]</code>,<br>  <code>java.lang.IndexOutOfBoundsException
  Inconsistency detected. Invalid item position 16(offset:16).state:64</code>,  <code>java.lang.IllegalArgumentException: Scrapped or attached views may not be recycled. isScrap:false isAttached:true</code>，<br>  类似上面的崩溃相信使用过DiffUtil应该都不陌生，根本原因是列表的数据变化的时候没有立刻调用adapter刷新列表，而DiffUtil的计算需要放在异步线程来处理，需要操作数据和展示数据的在不用的线程，同步比较难控制,尤其是在列表长度变化的时候又更新比较频繁的时候。虽然提供<em>AsyncListDiffer</em>的帮助类，但并不能减少这些崩溃发生的概率，而且即使知道大概的原因，这些崩溃还是很难避免。</li>
</ul>
<h2 id="不易增、删、更新的列表"><a href="#不易增、删、更新的列表" class="headerlink" title="不易增、删、更新的列表"></a>不易增、删、更新的列表</h2><p>以更新列表为例：</p>
<p><strong>类似需要异步请求数据的</strong><br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fz73pvxepdj30qc046ac1.jpg" alt=""></p>
<p><strong>类似通知更新数据的：</strong><br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fz8y3v6fyhj30u00i2400.jpg" alt=""></p>
<ol>
<li><p>实现更新的方式可能有很多种方式，但需要注意:<br>不要在Holder里监听数据变化，不管是类似EventBus的广播还是LiveData，虽然如果项目里用到LiveData,可能在holder里通过<code>livedate.observer(context,Observer)</code>很方便监听回调，但是因为Holder的没有明显的生命周期，可能会频繁被复用以及Holder的回收不可见等状态不可控，如果是使用LiveData，导致被频繁绑定observer，或者出现内存泄漏等各种难以定位的问题。下面是Google关于列表View的使用建议</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">* When the async code is done, you should update the data, not the views. After updating the data, tell the adapter that the data changed. The RecyclerView gets note of this and re-renders your view.</div><div class="line">* When working with recycling views (ListView or RecyclerView), you cannot know what item a view is representing. In your case, that view gets recycled before the async work is done and is assigned to a different item of your data.</div><div class="line">* So never modify the view. Always modify the data and notify the adapter. bindView should be the place where you treat these cases.</div></pre></td></tr></table></figure>
<p> 简单来说就是<strong>异步数据结果回来不应该在Holder里直接改变view的状态，而是应该改变数据，然后通过adapter来改变View。</strong> 主要原因还是上面说的Holder创建与销毁，可见不可见等状态很难控制</p>
</li>
<li><p>不在Holder里更新就只能在外部更新，但如果使用了DiffUtil，外部更新数据不容易实现。首先异步数据获取到后或者广播通知列表中的数据需要变化时，找到需要的变更项更改数据,类型下面的实现</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> allDatas = ...</div><div class="line"></div><div class="line"><span class="comment">//广播通知变化，更新数据</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onDataChanged</span><span class="params">(<span class="keyword">data</span>:<span class="type">T</span>)</span></span> &#123;</div><div class="line">   <span class="keyword">val</span> updateItemIdex = allDatas.find(<span class="keyword">object</span>.dataFeture)</div><div class="line">   or </div><div class="line">   <span class="keyword">val</span> needChangeData = allDatas.find(<span class="keyword">object</span>.dataFeture)</div><div class="line">   needChangeData.info = <span class="keyword">data</span>.info</div><div class="line">   </div><div class="line">   allDatas.<span class="keyword">set</span>(updateItemIdex,<span class="keyword">data</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">or </div><div class="line"></div><div class="line"><span class="comment">// 异步请求得到数据，更新数据</span></div><div class="line">fub onDataFetched(<span class="keyword">data</span>:T) &#123;</div><div class="line">    <span class="keyword">val</span> updateItemIdex = allDatas.find(<span class="keyword">object</span>.dataFeture)</div><div class="line">    or </div><div class="line">    <span class="keyword">val</span> needChangeData = allDatas.find(<span class="keyword">object</span>.dataFeture)</div><div class="line">    needChangeData.info = <span class="keyword">data</span>.info</div><div class="line">    </div><div class="line">    allDatas.<span class="keyword">set</span>(updateItemIdex,<span class="keyword">data</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="comment">//在全部数据中找到需要变更的数据，更改数据中的某些值。这种更常见</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findIndex</span><span class="params">(dataFeture : <span class="type">Long</span>)</span></span>:T &#123;</div><div class="line">    <span class="keyword">return</span> allDatas.find...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//在全部数据中找到需要变更的数据位置Index,替换数据</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findIndex</span><span class="params">(dataFeture : <span class="type">Long</span>)</span></span>:Index &#123;</div><div class="line">    <span class="keyword">return</span> allDatas.find...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把列表数据更新后，需要让UI的Item也同步更新</p>
<ul>
<li><p>一种是局部刷新：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adapter.notifyItemChanged(updateItemIdex);</div></pre></td></tr></table></figure>
<p>直接刷新单个Item很容易出现<a href="#jump1">不同线程同时处理数据带来的崩溃问题等</a>，再具体点这种情况是此时有类似mAdapter.setDatas(mDatas)刷新全量列表的行为，而此时的新的列表的长度和原来的不同，就有可能出现上述的崩溃。全量和局部可能都是基于通知或异步数据的结果所有很难控制先后顺序。</p>
</li>
</ul>
</li>
</ol>
<pre><code>* 还有一种是调用全量更新：

 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(<span class="keyword">new</span> DiffCallBack(mDatas, newDatas), <span class="keyword">true</span>);</div><div class="line"></div><div class="line">diffResult.dispatchUpdatesTo(mAdapter);</div><div class="line"></div><div class="line">mDatas = newDatas;</div><div class="line">mAdapter.setDatas(mDatas);</div></pre></td></tr></table></figure>
</code></pre><p>   使用了DiffUtil的原因，可能会觉得不会刷新所有的UI，这样性能会提高。但这样使用会出现新的问题，这种方式有个很严重的问题就是每次都要进行DiffCallBack的差分运算，虽然可以异步线程里处理，但是数据量较大，异步数据较多，更新频繁的时候会导致cpu被大量占用，从而带来更严重的界面卡顿问题。<br>    <span id = "jump2">  </p>
<p>   还有很麻烦的地方就是一个异步结果返回更改单个Item里的数据时，这时很有可能你看不到列表的更新。StackOverflow 有类似的问题：<a href="https://stackoverflow.com/questions/46008457/update-single-item-in-recyclerview-with-diffutil">Update single item in RecyclerView with DiffUtil</a>。因为每次更新的时候你需要<strong>new一个新的对象</strong>，然后将不需要改变的内容复制，需要改变的进行赋值。而不是像上面那样找到原来的数据进行更改局部，因为原数据<strong>对象</strong>已经在源数据列表里，虽然创建新的列表，但在更新单个对象的时候因为是同一个对象所以旧的数据列表肯定同步更新，导致做差分对比的结果肯定是不需要更新UI(因为是同一个对象)，所以只能创建新的对象，这对更新频繁和每个Item有很多异步返回数据的列表来说是个很大的消耗，写起来也会非常非常繁琐。</p>
<p>同样的，在一些频繁插入、删除、增加数据的列表项使用不当也有容易出现各种各样的问题。</p>
<h2 id="diffadapter：一种高效、高性能的方案"><a href="#diffadapter：一种高效、高性能的方案" class="headerlink" title="diffadapter：一种高效、高性能的方案"></a>diffadapter：一种高效、高性能的方案</h2><p><a href="https://github.com/SilenceDut/diffadapter">diffadapter</a>就是根据实际项目中各种复杂的列表需求，同时为了解决DiffUtil使用不方便，容易出错而实现的一个<strong>高效，高性能的列表库，侵入性低，方便接入</strong>，致力于将列表需求的开发精力用于具体的Item Holder上，而不用花时间在一些能通用的和业务无关的地方。使用DiffUtil来做最小更新，屏蔽外部调用<strong>DiffUtil</strong>的接口。只用实现简单的数据接口和展示数据的Holder，不用自己去实现Adapter来管理数据和Holder之间的关系，不用考虑DiffUtil的实现细节,就能快速的开发出一个高性能的复杂列表需求。</p>
<p>先看下demo的效果，图像url，名称，价格都是异步或者通知变化的数据。</p>
<p>进行随机的全量数显，局部刷新，插入，删除等操作。</p>
<p><a href="https://github.com/SilenceDut/diffadapter/blob/master/media/demo.gif">demo.gif</a></p>
<h2 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h2><ul>
<li>使用DiffUtil来找出最小需要更新的Item集合，使用者无需做任何DiffUtil的配置即可实现高效的列表</li>
<li>提供方便，稳定的更新、删、插入、查询方法，适用于各种非常频繁，复杂的场景（如因为异步或通知的原因同时出现插入，删除，全量设置的情况）</li>
<li>更友好方便的异步数据更新方案</li>
<li>简单配置就可实现多Type视图的列表</li>
</ul>
<h2 id="Using"><a href="#Using" class="headerlink" title="Using"></a>Using</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><strong>Step 1：继承<code>BaseMutableData</code>，主要实现<code>areUISame(newData: AnyViewData)</code> 和 <code>uniqueItemFeature()</code></strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnyViewData</span></span>(<span class="keyword">var</span> id : <span class="built_in">Long</span> ,<span class="keyword">var</span> any : String) : BaseMutableData&lt;AnyViewData&gt;() &#123;</div><div class="line"></div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">         <span class="comment">//数据展示的layout，也是和Holder一一对应的唯一特征</span></div><div class="line">         const <span class="keyword">val</span> VIEW_ID = R.layout.holder_skins</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemViewId</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</div><div class="line">       </div><div class="line">        <span class="keyword">return</span> VIEW_ID</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areUISame</span><span class="params">(newData: <span class="type">AnyViewData</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</div><div class="line">        <span class="comment">// 判断新旧数据是否展示相同的UI,如果返回True,则表示UI不需要改变，不会updateItem</span></div><div class="line">       </div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.any == newData.any</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">uniqueItemFeature</span><span class="params">()</span></span>: Any &#123;</div><div class="line">        <span class="comment">// 返回可以标识这个Item的特征，比如uid,id等,用来做UI差分已经可以动态</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Step 2：继承<code>BaseDiffViewHolder&lt;T extends BaseMutableData&gt;</code>，泛型类型传入上面定义的<code>AnyViewData</code></strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnyHolder</span></span>(itemView: View, recyclerAdapter: DiffAdapter): BaseDiffViewHolder&lt;AnyViewData&gt;( itemView,  recyclerAdapter)&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemViewId</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> AnyViewData.VIEW_ID</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateItem</span><span class="params">(<span class="keyword">data</span>: <span class="type">AnyViewData</span>, position: <span class="type">Int</span>)</span></span> &#123;</div><div class="line">        根据AnyViewData.VIEW_ID对应的layout来更新Item</div><div class="line">        Log.d(TAG,<span class="string">"updateItem <span class="subst">$data</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Step 3：注册，显示到界面</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> diffAdapter = DiffAdapter(<span class="keyword">this</span>)</div><div class="line"></div><div class="line"><span class="comment">//注册类型，不分先后顺序</span></div><div class="line">diffAdapter.registerHolder(AnyHolder::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>, <span class="type">AnyViewData.VIEW_ID)</span></span></div><div class="line">        diffAdapter.registerHolder(AnyHolder2::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>, <span class="type">AnyViewData2.VIEW_ID)</span></span></div><div class="line"></div><div class="line">diffAdapter.registerHolder(AnyHolder3::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>, <span class="type">AnyViewData3.VIEW_ID)</span></span></div><div class="line"></div><div class="line"><span class="keyword">val</span> linearLayoutManager = LinearLayoutManager(<span class="keyword">this</span>)</div><div class="line">recyclerView.layoutManager = linearLayoutManager</div><div class="line">recyclerView.adapter = diffAdapter</div><div class="line"></div><div class="line"><span class="comment">//监听数据变化</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onDatached</span><span class="params">(datas : <span class="type">List</span>&lt;<span class="type">BaseMutableData</span>&lt;*&gt;&gt;)</span></span> &#123;</div><div class="line">    diffAdapter.datas = adapterListData</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只需要上面几步，就可以完成如类似下图的多type列表,其中数据源里的每个BaseMutableData的getItemViewId()决定着用哪个Holder展示UI。<br>(以上均用<code>kotlin</code>实现，<code>Java</code>使用不受任何限制)</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzbiv9fcc5j30gq19ywq2.jpg" alt=""></p>
<h3 id="增、插入、删除、修改（更新）"><a href="#增、插入、删除、修改（更新）" class="headerlink" title="增、插入、删除、修改（更新）"></a>增、插入、删除、修改（更新）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T extends BaseMutableData&gt; <span class="function"><span class="keyword">void</span> <span class="title">addData</span><span class="params">(T data)</span> </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteData</span><span class="params">(BaseMutableData data)</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteData</span><span class="params">(<span class="keyword">int</span> startPosition, <span class="keyword">int</span> size)</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> <span class="title">insertData</span><span class="params">(<span class="keyword">int</span> startPosition ,List&lt;? extends BaseMutableData&gt; datas)</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateData</span><span class="params">(BaseMutableData newData)</span></span></div></pre></td></tr></table></figure>
<p>上述接口在调用的时机，频率都很复杂的场景下也不会引起崩溃</p>
<p>使用updateData(BaseMutableData newData)时，newData可以是新new的对象，也可以是修改后的原对象，不会出现<a href="#jump2">使用DiffUtil更新单个数据无效</a><br>的问题</p>
<h3 id="高阶用法"><a href="#高阶用法" class="headerlink" title="高阶用法"></a>高阶用法</h3><p>基本用法中<strong>Data和Holder绑定的模式并没什么特殊之处，早在两年前的项目<a href="https://github.com/SilenceDut/KnowWeather">KnowWeather</a>就已经用上这种思想，现在只是结合DiffUtil以及其他的疑难问题解决方案将其开源，diffadapter最核心的地方在于高性能和异步获取数据或者通知数据变化时列表的更新上</strong></p>
<h4 id="多数据源异步更新"><a href="#多数据源异步更新" class="headerlink" title="多数据源异步更新"></a>多数据源异步更新</h4><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fz73pvxepdj30qc046ac1.jpg" alt=""><br>以一个类似的Item为例，这里认为服务器返回的数据列表只包含uid，也就是<code>List&lt;Long&gt; uids</code>，个人资料，等级，贵族等都属于不同的协议。下面展示的是异步获取个人资料展示的头像和昵称的情况，其他的可以类比。</p>
<p><strong>Step 1:定义ViewData</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemViewData</span></span>(<span class="keyword">var</span> uid:<span class="built_in">Long</span>, <span class="keyword">var</span> userInfo: UserInfo?, <span class="keyword">var</span> anyOtherData: Any ...) : BaseMutableData&lt;ItemViewData&gt;() &#123;</div><div class="line"></div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        const <span class="keyword">val</span> VIEW_ID = R.layout....</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemViewId</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> VIEW_ID</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areUISame</span><span class="params">(newData: <span class="type">UserInfo</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userInfo?.portrait == newData.userInfo?.portrait &amp;&amp; <span class="keyword">this</span>.userInfo?.nickName == newData.userInfo?.nickName &amp;&amp; <span class="keyword">this</span>.anyOtherData == newData.anyOtherData</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">uniqueItemFeature</span><span class="params">()</span></span>: Any &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.uid</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>数据类ItemViewData包含所有需要显示到Item上的信息，这里只处理和个人资料相关的数据，<code>anyOtherData: Any ...</code>表示Item所需的其他数据内容</p>
<p>BaseMutableData里有个默认的方法<code>allMatchFeatures(@NonNull Set&lt;Object&gt; allMatchFeatures)</code>，不需要显示调用，这里当外部有异步数据变化时，提供当前BaseMutableData用来匹配变化的异步数据的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendMatchFeature</span><span class="params">(@NonNull Set&lt;Object&gt; allMatchFeatures)</span> </span>&#123;</div><div class="line">    allMatchFeatures.add(uniqueItemFeature());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认添加了uniqueItemFeature(),allMatchFeatures是个Set，可以重写方法添加多个用来匹配的特征。</p>
<p><strong>Step 2:定义View Holder，同基本用法</strong></p>
<p><strong>Step 3:监听数据变化，更新列表</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用于监听请求的异步数据，userInfoData变化时与此相关的数据</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">val</span> userInfoData = MutableLiveData&lt;UserInfo&gt;()</div><div class="line"></div><div class="line"><span class="comment">//在adapter里监听数据变化</span></div><div class="line">diffAdapter.addUpdateMediator(userInfoData, <span class="keyword">object</span> : UpdateFunction&lt;UserInfo, ItemViewData&gt; &#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">providerMatchFeature</span><span class="params">(input: <span class="type">UserInfo</span>)</span></span>: Any &#123;</div><div class="line">        <span class="keyword">return</span> input.uid</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">applyChange</span><span class="params">(input: <span class="type">UserInfo</span>, originalData: <span class="type">ItemViewData</span>)</span></span>: ItemViewData &#123;</div><div class="line">        </div><div class="line">       <span class="keyword">return</span> originalData.userInfo = input</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 任何通知数据获取到的通知</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">asyncDataFetch</span><span class="params">(userInfo : <span class="type">UserInfo</span>)</span></span> &#123;</div><div class="line">    userInfoData.value = userInfo</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样当asyncDataFetch接收到数据变化的通知的时候，改变userInfoData的值，adapter里对应的Item就会更新。其中找到adapter中需要更新的Item是关键部分，主要由实现<code>UpdateFunction</code>来完成，实现<code>UpdateFunction</code>也很简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UpdateFunction</span>&lt;<span class="title">I</span>,<span class="title">R</span> <span class="keyword">extends</span> <span class="title">BaseMutableData</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</div><div class="line">     * 匹配所有数据，及返回类型为R的所有数据</div><div class="line">     */</span></div><div class="line">    Object MATCH_ALL = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="comment">/**</div><div class="line">     * 提供一个特征，用来查找列表数据中和此特征相同的数据</div><div class="line">     * <span class="doctag">@param</span> input 用来提供查找数据和最终改变列表的数据</div><div class="line">     * <span class="doctag">@return</span> 用来查找列表中的数据的特征项</div><div class="line">     */</span></div><div class="line">    <span class="function">Object <span class="title">providerMatchFeature</span><span class="params">(@NonNull I input)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</div><div class="line">     * 匹配到对应的数据，如果符合条件的数据有很多个，可能会被回调多次</div><div class="line">     * <span class="doctag">@param</span> input 是数据改变的部分数据源</div><div class="line">     * <span class="doctag">@param</span> originalData 需要改变的数据项</div><div class="line">     * <span class="doctag">@return</span> 改变后的数据项</div><div class="line">     */</span></div><div class="line">    <span class="function">R <span class="title">applyChange</span><span class="params">(@NonNull I input,@NonNull R originalData)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>UpdateFunction</code>用来提供异步数据获取到后数据用来和列表中的数据匹配的规则和根据规则找到需要更改的对象后如果改变原对象，剩下的更新都由<code>diffadapter</code>来处理。如果符合条件的数据有很多个，<code>applyChange(@NonNull I input,@NonNull R originalData)</code>会被回调多次。如下时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">Object <span class="title">providerMatchFeature</span><span class="params">(@NonNull I input)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> UpdateFunction.MATCH_ALL</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>applyChange</code>回调的次数就和列表中的数据量一样多。</p>
<p>如果同一种匹配规则<code>providerMatchFeature</code>对应多种Holder类型，<code>UpdateFunction&lt;I,R&gt;</code>的返回数据类型R就可以直接设为基类的<code>BaseMutableData</code>，然后再applyChange里在具体根据类型来处理不同的UI。</p>
<h3 id="最高效的Item局部更新方式-——-payload"><a href="#最高效的Item局部更新方式-——-payload" class="headerlink" title="最高效的Item局部更新方式 —— payload"></a>最高效的Item局部更新方式 —— payload</h3><p>DiffUtil 能让一个列表中只更新部分变化的Item,payload能让同一个Item只更新需要变化的View,这种方式非常适合同一个Item有多个异步数据源的,同时又对性能有更高要求的列表。</p>
<p><strong>Step 1:重写BaseMutableData的appendDiffPayload</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemViewData</span></span>(<span class="keyword">var</span> uid:<span class="built_in">Long</span>, <span class="keyword">var</span> userInfo: UserInfo?, <span class="keyword">var</span> anyOtherData: Any ...) : BaseMutableData&lt;ItemViewData&gt;() &#123;</div><div class="line"></div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        const <span class="keyword">val</span> KEY_BASE_INFO = <span class="string">"KEY_BASE_INFO"</span></div><div class="line">        const <span class="keyword">val</span> KEY_ANY = <span class="string">"KEY_ANY"</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">/**</div><div class="line">     * 最高效的更新方式，如果不是频繁更新的可以不实现这个方法</div><div class="line">     */</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">appendDiffPayload</span><span class="params">(newData: <span class="type">ItemViewData</span>, diffPayloadBundle: <span class="type">Bundle</span>)</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.appendDiffPayload(newData, diffPayloadBundle)</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.userInfo!= newData.userInfo) &#123;</div><div class="line">            diffPayloadBundle.putString(KEY_BASE_INFO, KEY_BASE_INFO)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.anyData != newData.anyData) &#123;</div><div class="line">            diffPayloadBundle.putString(KEY_ANY, KEY_ANY)</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认用Bundle存取变化，无需存具体的数据，只需类似设置标志位，表明Item的哪部分数据发生了变化。</p>
<p><strong>Step 2 :需要重写BaseDiffViewHolder里的<code>updatePartWithPayload</code></strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItemViewHolder</span></span>(itemViewRoot: View, recyclerAdapter: DiffAdapter): BaseDiffViewHolder&lt;ItemViewData&gt;( itemViewRoot,  recyclerAdapter)&#123;</div><div class="line">     </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">updatePartWithPayload</span><span class="params">(<span class="keyword">data</span>: <span class="type">ItemViewData</span>, payload: <span class="type">Bundle</span>, position: <span class="type">Int</span>)</span></span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(payload.getString(ItemViewData.KEY_BASE_INFO)!=<span class="literal">null</span>) &#123;</div><div class="line">        updateBaseInfo(<span class="keyword">data</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(payload.getString(ItemViewData.KEY_ANY)!=<span class="literal">null</span>) &#123;</div><div class="line">        updateAnyView(<span class="keyword">data</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据变化的标志位，更新Item中需要变化部分的View</p>
<h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p><strong>更详细，多样的使用方式和细节见<a href="https://github.com/SilenceDut/diffadapter">diffadapter</a></strong>，有详细的demo和使用说明，demo用kotlin实现，使用了<strong>mvvm</strong>和<strong>模块化</strong>的框架方式。</p>
<p>这种方式也是目前能想到的比较好的异步数据更新列表的方式，非常欢迎一起探讨更多的实现方式。</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2019/01/24/如何优雅的实现一个高效、高性能、异步数据实时刷新的列表/#post-footer" class="postShorten-excerpt_link link">
                                注释和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/11/26/优雅的使用Handler,避免内存泄漏和页面崩溃/">
                            通过LifecycleOwner,优雅的使用Handler
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-11-26T21:22:24+08:00">
	
		    11月 26, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/all-categories/Android/">Android</a>, <a class="category-link" href="/all-categories/Android/OpenSourceProject/">OpenSourceProject</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <h3 id="目前的问题"><a href="#目前的问题" class="headerlink" title="目前的问题"></a>目前的问题</h3><p>Handler的使用在Android日常开发中占用很大的比重，尤其在界面开发中，经常被用来做一些延迟执行的任务。但Handler带来的问题也很多，最常见的比如页面退出未执行的任务没有被移除导致内存泄漏，以及可能的由于界面已不存在而导致的崩溃。如下，如果不及时移除就可能造成上述问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mHander.postDelayed(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="comment">//do something</span></div><div class="line">    &#125;</div><div class="line">&#125;,<span class="number">1000</span>);</div></pre></td></tr></table></figure>
<p>这些问题一般都比较容易想到，也容易解决，常用的方式是缓存一个Runnable变量在使用的类中，然后在页面生命周期结束移除</p>
                    
                        <a href="/2018/11/26/优雅的使用Handler,避免内存泄漏和页面崩溃/" class="postShorten-excerpt_link link">
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/08/12/一种基于接口化、清晰易读的路由框架——Hub/">
                            一种基于接口、简洁易用的通信框架——Hub
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-08-12T21:22:24+08:00">
	
		    8月 12, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/all-categories/Java/">Java</a>, <a class="category-link" href="/all-categories/Java/Android/">Android</a>, <a class="category-link" href="/all-categories/Java/Android/OpenSourceProject/">OpenSourceProject</a>, <a class="category-link" href="/all-categories/Java/Android/OpenSourceProject/designpattern/">designpattern</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <h3 id="Hub库的由来"><a href="#Hub库的由来" class="headerlink" title="Hub库的由来"></a><a href="https://github.com/SilenceDut/Hub">Hub</a>库的由来</h3><p>在准备重构<a href="https://github.com/SilenceDut/KnowWeather">知天气</a>时，决定使用谷歌推出的<br><a href="https://developer.android.com/topic/libraries/architecture/index.html">Android Architecture Components</a>架构，同时借鉴<a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286672&amp;idx=1&amp;sn=4d9db00c496fcafd1d3e01d69af083f9">微信Android模块化架构重构实践</a>的模块化的思想，抛弃之前的MVP,单一模块的方式对项目进行重构，同时积累一些经验来对工作中的项目进行优化。AAC和模块化的优点就不多介绍了，AAC很容易引入，谷歌在Android的API层面提供了大量的支持，模块化主要的难点就是模块间没有直接引用，如何通信的问题(以下用module来代替模块，也就是Android开发中的nodule),了解到的有主要以下几种思想：</p>
                    
                        <a href="/2018/08/12/一种基于接口化、清晰易读的路由框架——Hub/" class="postShorten-excerpt_link link">
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/01/09/由ReentrantLock分析JUC的核心AQS/">
                            由ReentrantLock分析JUC的核心AQS
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-01-09T21:22:24+08:00">
	
		    1月 09, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/all-categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <p><a href="http://www.silencedut.com/2016/06/03/并发的学习与使用">并发的学习与使用系列</a> 第八篇</p>
<p>AQS是AbstractQueuedSynchronizer的简称，是并发组件包java.util.concurrent也就是JUC(Java Util Concurrency)的核心，以及很多并发组件如前面几篇中介绍到的ReentrantLock，Condition,BlockingQueue以及线程池里使用的worker等都是基于其实现的，将很多复杂的，繁琐的并发控制过程封装起来，便于其他并发工具类来实现更多，方便的功能，其主要通过volatile和UnSafe类的原子操作（Atomic相关）来实现阻塞和同步，之前的文章<a href="http://www.silencedut.com/2016/06/12/显示锁（Lock）及Condition的学习与使用">并发的学习与使用系列</a>提到里Lock的实现类ReentrantLock是一个可重入的，可实现公平的锁。下面通过ReentrantLock的源码来看看其是怎么实现的。</p>
                    
                        <a href="/2017/01/09/由ReentrantLock分析JUC的核心AQS/" class="postShorten-excerpt_link link">
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/12/14/关于Java GC的理解/">
                            关于Java GC的理解
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-12-14T20:55:29+08:00">
	
		    12月 14, 2016
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/all-categories/JVM/">JVM</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <p>关于Java垃圾回收机制，网上介绍的资料很多，一般都是一些固定的知识，这些在书上都能找到相应的出处，这里希望讲一些更加细节的问题。如果你对Java虚拟机的知识不了解，建议先去了解一下，这里都是一些概念上的理解，主要基于HotSpot虚拟机。</p>
                    
                        <a href="/2016/12/14/关于Java GC的理解/" class="postShorten-excerpt_link link">
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/12/06/知天气——天气尽在掌握之中/">
                            知天气——天气尽在掌握之中
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-12-06T22:55:29+08:00">
	
		    12月 06, 2016
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/all-categories/OpenSourceProject/">开源项目</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <p><strong>该项目已经重构,see <a href="https://github.com/SilenceDut/KnowWeather">KnowWeather</a></strong></p>
<p>已经有那么多的天气应用了，这个项目有什么不一样的地方吗？为什么还要做这个项目呢？</p>
<ul>
<li>第一个目的是熟悉项目从0到上线的过程，平常的工作中大部分是在做很小部分的业务开发，对项目的整体框架没机会实践。</li>
<li>熟悉新的框架和技术，先进行应用，感受其优缺点，然后应用到工工作中，因为很多新技术学习是需要时间的，而且其特性也是需要提前了解的，在未了解的情况直接用到公司的项目会花费时间并且可能会带来风险。</li>
</ul>
                    
                        <a href="/2016/12/06/知天气——天气尽在掌握之中/" class="postShorten-excerpt_link link">
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/11/02/Android动态加载之ClassLoader详解/">
                            Android动态加载之ClassLoader详解
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-11-02T23:19:10+08:00">
	
		    11月 02, 2016
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/all-categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <p>Dalvik虚拟机如同其他Java虚拟机一样，在运行程序时首先需要将对应的类加载到内存中。而在Java标准的虚拟机中，类加载可以从class文件中读取，也可以是其他形式的二进制流。因此，我们常常利用这一点，在程序运行时手动加载Class，从而达到代码动态加载执行的目的。<br>只不过Android平台上虚拟机运行的是Dex字节码,一种对class文件优化的产物,传统Class文件是一个Java源码文件会生成一个.class文件，而Android是把所有Class文件进行合并，优化，然后生成一个最终的class.dex,目的是把不同class文件重复的东西只需保留一份,如果我们的Android应用不进行分dex处理,最后一个应用的apk只会有一个dex文件。</p>
                    
                        <a href="/2016/11/02/Android动态加载之ClassLoader详解/" class="postShorten-excerpt_link link">
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/10/06/常见的设计模式学习/">
                            常见的设计模式学习
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-10-06T17:22:29+08:00">
	
		    10月 06, 2016
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/all-categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <h2 id="OO基础"><a href="#OO基础" class="headerlink" title="OO基础"></a>OO基础</h2><ul>
<li>抽象</li>
<li>封装</li>
<li>多态</li>
<li>继承</li>
</ul>
                    
                        <a href="/2016/10/06/常见的设计模式学习/" class="postShorten-excerpt_link link">
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/09/09/Android常用开源框架的源码解读套路/">
                            Android常用开源框架的源码解读套路
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-09-09T23:27:12+08:00">
	
		    9月 09, 2016
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/all-categories/OpenSourceProject/">开源项目</a>, <a class="category-link" href="/all-categories/OpenSourceProject/源码分析/">源码分析</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <p>在学习Android过程中，会使用到很多开源框架，而使用时对框架的实现方式应有一定的了解，这个过程最好的方式就是阅读源码，毕竟源码说明一切。但开源框架很多，不时会有新的出现，而且对一些通用框架来说，一般代码量非常庞大，所以正确的阅读姿势很重要。一般来说有下面几个要点:</p>
<ul>
<li>明确阅读源码的目的是对整体有个了解而非细节，对开源框架来说就是先找这个框架的特点，其他相同业务框架相比的优点和不足，这也是选择的考虑的重点；</li>
<li>厘清一个框架的核心点和辅助点；</li>
<li>最重要的是总结相似框架的架构模式与习惯，慢慢的就会有一套自己的阅读套路。</li>
</ul>
<p>这里主要通过常用的网络请求库OkHttp，图片加载库Picasso，事件总线库EventBus等对上面提到的几点进行解读。</p>
                    
                        <a href="/2016/09/09/Android常用开源框架的源码解读套路/" class="postShorten-excerpt_link link">
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/09/04/Router—一个高效，使用方便，基于动态代理实现的Android事件总线库/">
                            Router—一个高效，使用方便，基于动态代理实现的Android事件总线库
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-09-04T19:55:29+08:00">
	
		    9月 04, 2016
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/all-categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <p>项目地址：<a href="https://github.com/SilenceDut/Router">Router</a></p>
<p><a href="https://silencedut.github.io/2016/08/12/代理模式的学习与应用">代理模式的学习与应用</a>介绍了代理模式的原理及简单使用方式，<a href="https://github.com/SilenceDut/Router">Router</a>就是基于此实现了一个Android间组件、线程间方便通信的库。</p>
<h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p>在Android中的，EventBus是开源最流行的事件总线库，大大简化了应用程序内各组件间、组件与后台线程间的通信。之前的个人项目<a href="https://github.com/SilenceDut/NBAPlus">NBAPlus</a>也是使用EventBus来简化开发，但在使用过程中有一些问题。</p>
                    
                        <a href="/2016/09/04/Router—一个高效，使用方便，基于动态代理实现的Android事件总线库/" class="postShorten-excerpt_link link">
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-next">
            <a class="btn btn--default btn--small" href="/page/2/">
                    <span>下一页</span>
                <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
        </li>
        
        <li class="pagination-number">第 1 页 共 3 页</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 SilenceDut. All Rights Reserved.
    </span>
  	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.png"/>
        
            <h4 id="about-card-name">SilenceDut</h4>
        
            <h5 id="about-card-bio"><p>talk is cheap,here are my blog</p>
</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android engineer</p>

            </h5>
        
        
            <h5 id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                广东，广州
            </h5>
        
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
    </body>
    <!--SCRIPTS-->
<script src="/assets/js/script-i4qo6jx6jji9fg0dftpya6ivemizsbow4fhow76d8dwpm7m1wbvi378ssumx.min.js"></script>
<!--SCRIPTS END-->



</html>
